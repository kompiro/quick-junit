package junit.extensions.eclipse.quick.javadoc.ui.handlers;

import java.util.ArrayList;
import java.util.List;

import junit.extensions.eclipse.quick.javadoc.SearchJavaClassFromDocTagVisitor;
import junit.extensions.eclipse.quick.javadoc.ui.JavaDocUIActivator;

import org.eclipse.core.commands.Command;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.common.NotDefinedException;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IMember;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.search.SearchMatch;
import org.eclipse.jdt.core.search.SearchRequestor;
import org.eclipse.jdt.ui.JavaUI;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.swt.widgets.Shell;

public class OpenTestingContextHandler extends AbstractJavaDocHandler {

	private static class TypeLabelProvider extends LabelProvider {
        public String getText(Object element) {
        	if(element == null){
				return "null";        		
        	} 
        	if (element instanceof IType) {
				return ((IType) element).getFullyQualifiedName();
			}
        	if(element instanceof IMethod){
				IMethod method = (IMethod) element;
				return method.getDeclaringType().getFullyQualifiedName() + "#" + method.getElementName();				
			}
        	String message = String.format("Illegal Element is gave '%s'",element.toString());
			throw new IllegalArgumentException(message);
        }
    }
	private static final class SearchJavaClassRequestor extends SearchRequestor {
    	
    	private List<IJavaElement> results = new ArrayList<IJavaElement>();

		@Override
		public void acceptSearchMatch(SearchMatch match) throws CoreException {
			results.add((IJavaElement) match.getElement());
		}

		public List<IJavaElement> getResults() {
			return results;
		}
	}

	public OpenTestingContextHandler() {
	}

	public Object doExecute(ExecutionEvent event) throws ExecutionException {
		SearchJavaClassRequestor requestor = new SearchJavaClassRequestor();
		try {
			IJavaElement element = getElementOfJavaEditor();
			if (element instanceof IMethod || element instanceof IType) {
				IMember refs = (IMember) element;
				ASTParser parser = ASTParser.newParser(AST.JLS3);
				parser.setKind(ASTParser.K_CLASS_BODY_DECLARATIONS);
				String source = refs.getSource();
				if(source == null){
					return null;
				}
				parser.setSource(source.toCharArray());
				ASTNode node = parser.createAST(new NullProgressMonitor());
				ASTVisitor visitor = new SearchJavaClassFromDocTagVisitor(refs.getDeclaringType(),requestor);
				node.accept(visitor);
			}
			List<IJavaElement> results = requestor.getResults();
			Shell parent = getWorkbenchWindow().getShell();
			if(!results.isEmpty()){	
				IJavaElement selectedType = selectType(event.getCommand(),results,parent);
		        JavaUI.openInEditor(selectedType,true,false);
			}
		} catch (JavaModelException e) {
			JavaDocUIActivator.getDefault().handleSystemError(e, this);
		} catch (CoreException e) {
			JavaDocUIActivator.getDefault().handleSystemError(e, this);
		} catch (NotDefinedException e) {
			JavaDocUIActivator.getDefault().handleSystemError(e, this);
		}
		return null;
	}
	    
	private IJavaElement selectType(Command command,List<IJavaElement> types,Shell shell) throws NotDefinedException {
    	if(types.size() == 1) return types.get(0);
        PopupTableSelector selector = new PopupTableSelector(shell, types);
        selector.setTitle(command.getName());
        selector.setCommandForward(command.getId());
        selector.setLabelProvider(new TypeLabelProvider());
        return (IJavaElement) selector.select();
    }
    
}
